---
title: 动态规划
date: 2025-04-15 21:45:35
tags: 动态规划
---







​	最近在做动态规划题的时候时常感到困惑，为什么这个题的边界要初始化，为什么这个题的边界不用初始化，为什么这个两个题明明代码都是一样的初始化的条件却不同，写算法题的时候遇到这种情况真的很痛苦，很想手动模拟，一个一个的算出来对应的值，看一下究竟为什么。但是受限于时间，我先记录对这种情况进行记录，之后慢慢深究。

首先是LeetCode上的[62. 不同路径](https://leetcode.cn/problems/unique-paths/)，这个题我第一遍的时候写了两种做法，两种做法的整体思路都是一样的，但是对应的边界条件不同。代码如下：

```java
//写法1：
public int uniquePaths(int m, int n) {
    int[][] f = new int[m][n4];

    for(int i = 0; i < m; i ++){
        f[i][0] = 1;
    }

    for(int j = 0; j < n; j ++){
        f[0][j] = 1;
    }

    for(int i = 1; i < m; i ++){
        for(int j = 1; j < n; j ++){
            f[i][j] = f[i - 1][j] + f[i][j - 1];
        }
    }
    return f[m - 1][n - 1];
}
```

写法1很好理解，只需要初始化最上边和最右边的所有路径数为1就好，剩下的就是状态转移了。

```java
//写法2：
public int uniquePaths(int m, int n) {
    int[][] f = new int[m + 1][n + 1];

   	f[0][1] = 1;
    for(int i = 0; i < m; i ++){
        for(int j = 0; j < n; j ++){
            f[i + 1][j + 1] = f[i + 1][j] + f[i][j + 1];
        }
    }
    return f[m][n];
}
```

写法二考虑了边界情况，将动态规划数组初始化为0 -> m和0 -> n，这样i和j就可以从0开始遍历。但是这样带来一个问题，即原二维数组中的(0，0)对应动态规划数组中的(1，1)，因此就不能像写法一中那样进行初始化了，写法二中将f(0，1)初始化为1（也可以将f(1，0）初始化为1，只能初始化一个），f(0，1)对应的是二维数组中(-1，0)，也就是方格外的区域，这样初始化后，在第一次循环的时候会将f(1，1)初始化成1，而f(1，1)对应的是方格中的(0，0)。
