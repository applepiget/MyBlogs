---
title: 八股补充
date: 2025-04-19 13:45:19
tags:
---

##### 1.NIO的多路复用机制

​	NIO是基于IO多路复用模型的实现，它包含三个核心组件，分别是**Buffer、Channel、Sellector**。
​	1) NIO是面向缓冲区的，在NIO中所有的数据都是通过缓冲区处理的。Buffer就是缓冲区对象，无论读取还是写入，数据都是先进入Buffer的。Buffer的本质是一个数组，通常它是一个字节数组，也可以是其他类型的数组。Buffer是一个接口，它的实现类有ByteBuffer、CharBuffer、ShortBuffer、IntBuffer、LongBuffer、FloatBuffer、DoubleBuffer。
​	2）Channel是一个通道，可以通过它读取和写入数据。与流不同的是，流是单向的，而Channel是双向的。数据可以通过Channel读到Buffer里，也可以通过Channel写入到Buffer里。为了支持不同的设备，Channel接口有好几种子类，如FileChannel用于访问磁盘文件、SocketChannel和ServerSocketChannel用于TCP协议的网络通信、DatagramChannel用于UDP协议的网络通信。
​	3）Selector是多路复用器，可以通过它监听网络IO的状态。它可以不断轮询注册的Channel，如果某Channel上有连接、读取、写入事件发生，则这个Channel就处于就绪状态，就会被Selector轮询出来。所有被轮询出来的Channel集合，我们可以通过SelectionKey获取到，然后进行后续的IO操作。



##### 2.IO多路复用中select/poll/epoll各自的实现原理和区别？

​	1）select 使用位图管理 fd，每次调用都需要将 fd 集合从用户态复制到内核态。最大支持 1024 个文件描述符。
​	2）poll 使用动态数组管理 fd，突破了 select 的数量限制。
​	3）epoll 使用红黑树和链表管理 fd，每次调用只需要将 fd 集合从用户态复制到内核态一次，不需要重复复制。



##### 3.HTTPS 连接过程

​	1）**客户端发起请求：**客户端向服务器发送一个包含 SSL/TLS 版本信息、加密算法列表等的握手请求。
​	2）**服务器响应：**服务器收到请求后，返回自己的证书（包含服务器的公钥等信息）、SSL/TLS 版本、选择的加密算法等。
​	3）**客户端验证：**客户端验证服务器证书的有效性，如证书是否由可信的证书颁发机构颁发、是否过期等。验证通过后，生成一个随机的预主密钥，用服务器的公钥加密后发送给服务器。
​	4）**密钥交换：**服务器用自己的私钥解密得到预主密钥，然后双方根据预主密钥和之前协商的加密算法，生成会话密钥，用于后续的数据加密传输。
​	5）**数据传输：**客户端和服务器使用会话密钥对数据进行加密和解密，开始安全的数据传输。



##### 4.MySQL中版本链的回收机制

在MySQL中，版本链回收主要与InnoDB存储引擎的多版本并发控制（MVCC）机制相关，其回收机制如下：

**版本链的形成**

- InnoDB为每行数据记录添加了隐藏的列，包括 DB_TRX_ID （事务ID）和 DB_ROLL_PTR （回滚指针）。当数据被修改时，旧版本的数据会通过回滚指针链接起来，形成版本链。

**版本链回收时机**

- 事务提交时：事务提交后，其对数据的修改可能会产生新版本数据，此时会判断该事务产生的旧版本数据是否可以被回收。如果没有其他事务需要访问这些旧版本数据，那么它们就有可能被回收。

- Purge操作：MySQL后台有专门的Purge线程，会定期检查并清理不再需要的undo日志以及版本链中的旧数据版本。Purge操作会根据系统中活跃事务的情况，判断哪些版本链上的数据已经不再被任何事务引用，从而将其回收。

**版本链回收判断条件**

- 系统会通过判断事务的可见性来确定版本链上的数据是否可以被回收。如果一个数据版本的事务ID对于当前所有活跃事务都是不可见的，那么这个数据版本就可以被回收。例如，当一个事务提交后，新的事务看不到该事务修改之前的数据版本，那么这些旧版本数据在满足一定条件下就可以被回收。

**空间释放与重用**

- 回收版本链中的数据后，会释放相应的存储空间。这些释放的空间并不会立即返回给操作系统，而是由InnoDB存储引擎管理，用于后续的数据插入或更新操作，以提高存储空间的利用率。

版本链回收机制可以在保证数据一致性和并发访问正确性的前提下，有效地管理存储空间，避免版本链无限增长导致的性能问题和空间浪费。



**5.如何排查MySQL的死锁**

​	MySQL的InnoDB实现了**行级别锁：共享锁（S Lock）**和**排他锁（X Lock）**



**6.对 MySQL 进行增删改时 B + 树的变化**

##### 插入操作

- **叶子节点空间充足**：当插入一条新记录时，首先根据索引键值找到对应的叶子节点。如果该叶子节点还有足够的空间来存储新记录，就直接将新记录插入到叶子节点的合适位置，并保持节点内键值的有序性。
- **叶子节点空间已满**：若叶子节点已满，就需要进行节点分裂操作。具体做法是将该叶子节点分裂成两个新的叶子节点，把原节点中的键值平均分配到两个新节点中，同时将中间的键值提升到父节点中。如果父节点也因此满了，就继续向上分裂，直到根节点。若根节点分裂，会创建一个新的根节点。

##### 删除操作

- **叶子节点删除后仍满足最小填充要求**：删除记录时，先找到对应的叶子节点并删除该记录。如果删除后叶子节点中的键值数量仍然满足最小填充要求（通常是节点最大容量的一半），则不需要进行其他操作。
- **叶子节点删除后不满足最小填充要求**：若删除后叶子节点的键值数量低于最小填充要求，就需要进行节点合并或重新分配操作。可以尝试从相邻的兄弟节点借一个键值，或者将该叶子节点与相邻的兄弟节点合并。如果合并操作导致父节点的键值数量低于最小填充要求，就继续向上处理，可能会引发父节点的合并或重新分配，甚至可能会导致树的高度降低。

##### 修改操作

- **键值不变**：如果修改操作不改变索引键值，只需要更新叶子节点中对应记录的其他字段即可。
- **键值改变**：若修改操作改变了索引键值，相当于先删除原记录，再插入新记录。需要根据新的键值找到合适的叶子节点进行插入操作，同时删除原记录所在的位置。这可能会触发节点的分裂、合并或重新分配等操作。



##### 7.Insert一条数据会加什么锁

##### **前提**

1. InnoDB 默认规则

   有索引（主键 / 唯一键 / 普通索引）时，用 **行级锁**（只锁一行或相关索引）；

   无索引时，只能用 **表级锁**（锁整张表，阻塞所有人读写）。

2. 隔离级别影响

   **读已提交（RC）**：几乎不加间隙锁（简单场景只锁一行）；

   **可重复读（RR，默认）**：可能加间隙锁（防止插入导致的幻读，但 Insert 会尽量优化）。

##### **场景 1：插入到主键 / 唯一索引**

```sql
-- 表结构：id是主键（唯一索引）
CREATE TABLE t(id INT PRIMARY KEY, name VARCHAR(10));
-- 插入语句：INSERT INTO t(id, name) VALUES (1, 'a');
```

1. **记录锁（行锁）**：锁定主键索引中 `id=1` 这一行（X 锁，排他锁），阻止别人修改 / 删除这一行；

2. 插入**意向锁**在插入前，检查id=1前后是否有间隙（比如前一个是 0，后一个是 2，间隙是 (0,2)），加一个轻量级锁，告诉别人 “我要在这里插入”。

   重点：**插入意向锁不阻塞其他插入**（比如另一个事务插入 id=3，没问题），只阻塞想在同间隙插入唯一键冲突的操作。

- **结论**：**主键 / 唯一索引插入时，只锁当前行，间隙锁几乎不影响并发**。



##### **场景 2：插入到非索引列（比如 name 字段无索引）**

```sql
-- name字段没有索引
INSERT INTO t(id, name) VALUES (2, 'b');
```

InnoDB 找不到 name 的索引，只能通过主键 id=2 定位数据，所以：

1. **只锁主键索引的 id=2 这一行**（X 记录锁），和场景 1 一样；
2. **name 字段无索引，所以不会对 name 加锁**（因为无法通过 name 快速定位，只能全表扫描，所以锁在主键上）。

- **结论**：**非索引列插入，锁还是加在主键上，和普通主键插入一样**。



##### **场景 3：插入重复唯一键（比如主键已存在）**

```sql
-- 已有id=1，再次插入id=1
INSERT INTO t(id, name) VALUES (1, 'b');
```

1. 先检查主键唯一性，发现 id=1 已存在，**对 id=1 这一行加 X 记录锁**（防止其他事务同时修改这个 id）；
2. 发现冲突后，报错回滚，释放锁。

- **结论**：**唯一性检查会锁冲突行，阻止并发插入相同值**。



##### **场景 4：表中没有任何索引（极端情况）**

```sql
-- 无索引表（InnoDB会自动加隐藏主键，但用户无索引）
CREATE TABLE no_index (data VARCHAR(100));
INSERT INTO no_index VALUES ('a');
```

无索引时，InnoDB 无法用行级锁，只能加表级锁（IX 锁，意向排他锁）

1. 插入时锁定整张表，**阻塞其他事务的所有写操作**（读可能允许，取决于隔离级别）；
2. 性能极差，并发插入会排队。

- **结论**：**无索引表插入 = 表锁**
